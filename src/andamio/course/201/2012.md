---
{
  "title": "201.2: Multi-Signatures Transaction",
  "slt": ["201.2"],
  "type": "Lesson",
  "description": "Learn about creating multi-signature (multi-sig) transaction which requires more than one key to sign a transaction prior to the transaction being broadcast on a blockchain.",
  "videoURL": "",
  "lastEdited": "2024-02-07",
  "author": "Jingles",
}
---

## Why Multi-Signature Transaction?

A multi-signature transaction is a transaction that requires more than one key to sign a transaction prior to the transaction being broadcast on a blockchain. This is a security feature that is used to protect against theft and loss of funds. It is also used to protect against unauthorized access to funds. Multi-signature transactions are used in many different applications, including online wallets, exchanges, and smart contracts.

Here are some examples of how multi-signature transactions are used:

- when requires inputs from multiple wallets, Wallet A (50 ADA) and Wallet B (50 ADA) sends to Wallet C.
- when involves a smart contract to redeem assets
- when minting assets from a policy ID that does not belong to the payment wallet

## Lesson Overview

In this lesson, we will learn how to create a multi-signature transaction to mint an asset. The user will connect with a [CIP-30](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0030) compatible wallet and pay for the token. We will use the [App Wallet](https://meshjs.dev/apis/appwallet) will build a minting transaction and complete the transaction by signing using the [Browser Wallet](https://meshjs.dev/apis/browserwallet).

## Part 1: Connect user wallet and get wallet information

First, we will connect the user wallet and get the wallet information. We will use the [Browser Wallet](https://meshjs.dev/apis/browserwallet) to allow user to connect their wallet and get wallet information.

### Connect user wallet

To connect the user wallet, we will use the `connect` method of the [Browser Wallet](https://meshjs.dev/apis/browserwallet). This method will prompt the user to connect their wallet and return the wallet information.

We will use `CardanoWallet` component to connect the user wallet, you can learn in more details from the previous lessons.

```js
const Home: NextPage = () => {
  const { connected, wallet } = useWallet();

  return (
    <MeshProvider>
      <div>
        <CardanoWallet />
      </div>
    </MeshProvider>
  );
};
```

### Get wallet information

Next, we will create a mint button to trigger the minting transaction. To create the transaction, we need information from the user's wallet, UTXOs and change address.

The change address will be the address receiving the minted NFTs and the transaction's change. Additionally, we will need the client's wallet UTXOs to build the minting transaction.

```js
function MintButton() {
  const koiosProvider = new KoiosProvider("preprod");
  const { wallet } = useWallet();

  async function startMinting() {
    const recipientAddress = await wallet.getChangeAddress();
    const utxos = await wallet.getUtxos();
    console.log("starting minting", { recipientAddress, utxos });
  }

  return <button onClick={() => startMinting()}>Mint Token</button>;
}
```

## Part 2: Build minting transaction

In this session, we will build a minting transaction using the [App Wallet](https://meshjs.dev/apis/appwallet). You can think of the App Wallet as a wallet of the token policy owner.

### Initialize App Wallet

Create a new instance of the [App Wallet](https://meshjs.dev/apis/appwallet), we will also need a data provider, here we use the `KoiosProvider`.

```js
const koiosProvider = new KoiosProvider("preprod");

const appWallet = new AppWallet({
  networkId: 0,
  fetcher: koiosProvider,
  submitter: koiosProvider,
  key: {
    type: "mnemonic",
    words: [...],
  },
});
```

### Minting script

Next, let's define the forging script, which is a script that will be used to mint the token. The forging script will be used to create the minting transaction. This forging script will determine the token's policy ID.

```js
const appWalletAddress = appWallet.getPaymentAddress();
const forgingScript = ForgeScript.withOneSignature(appWalletAddress);
```

### Define token

Then, we define the token's metadata.

```js
const assetMetadata: AssetMetadata = {
  name: "Mesh Blue Banner",
  image: "https://meshjs.dev/logo-mesh/mesh.png",
  mediaType: "image/jpg",
  description: "This NFT is minted by Mesh (https://meshjs.dev/).",
};

const asset: Mint = {
  assetName: "MeshBlueBanner",
  assetQuantity: "1",
  metadata: assetMetadata,
  label: "721",
  recipient: recipientAddress,
};
```

### Create transaction

Finally, we are ready to create the minting transaction.

First we define the cost of the token and the receiver address for the price of the token.

Then we use the `largestFirst` algorithm to select UTXOs for this transaction. This is a simple algorithm that selects the UTXOs that has the largest amount of ADA first.

Next, we create the transaction, these are the inputs and outputs of the transaction:

- transaction inputs (the selected UTXOs)
- mint asset definitions
- send price of the token to the bank wallet address
- set the change address, all remaining lovelace and minted token will be sent to the change address

```js
// the price of the token pay to the `bankWalletAddress`
const costLovelace = "10000000"; // this is 10 ADA

// the receiver address for the price of the token
const bankWalletAddress =
  "addr_test1qzmwuzc0qjenaljs2ytquyx8y8x02en3qxswlfcldwetaeuvldqg2n2p8y4kyjm8sqfyg0tpq9042atz0fr8c3grjmysm5e6yx";

// use `largestFirst` algorithm to select UTXOs for this transaction
const selectedUtxos = largestFirst(costLovelace, utxos, true);

// create the transaction
const tx = new Transaction({ initiator: appWallet });
tx.setTxInputs(selectedUtxos);
tx.mintAsset(forgingScript, asset);
tx.sendLovelace(bankWalletAddress, costLovelace);
tx.setChangeAddress(recipientAddress);
const _unsignedTx = await tx.build();
```

### Sign transaction

Lastly, we will sign the transaction using the `signTx` method. Because this is a multi-signature transaction, we will set the `isMultiSig` parameter to `true`.

```js
const unsignedTx = await appWallet.signTx(_unsignedTx, true);
```

## Part 3: Complete the transaction

In this session, we will complete the transaction by signing the transaction using the client's wallet.

We have wrapped all the codes in part 2 into a function called `createTransaction`. We will use this function to create the transaction, getting the unsigned transaction and then sign the transaction using the client's wallet.

Like the application wallet, we will use the `signTx` method to sign the transaction. We will also set the `isMultiSig` parameter to `true`.

Finally, we will submit the transaction using the `submitTx` method.

```js
const { unsignedTx } = await createTransaction(recipientAddress, utxos);

const signedTx = await wallet.signTx(unsignedTx, true);
const txHash = await wallet.submitTx(signedTx);
```

## Full code

To try it out, you can start a new Next.js project and add the following code to the `pages/index.tsx` file.

```js
import { useState } from "react";
import type { NextPage } from "next";
import { CardanoWallet, useWallet } from "@meshsdk/react";
import {
  AppWallet,
  AssetMetadata,
  ForgeScript,
  largestFirst,
  KoiosProvider,
  UTxO,
  Mint,
  Transaction,
} from "@meshsdk/core";

const Home: NextPage = () => {
  const { connected } = useWallet();

  return (
    <div
      style={{
        width: "100%",
        height: "100vh",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <div
        style={{
          width: "400px",
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
        }}
      >
        <h1 style={{ marginBottom: "10px" }}>Mint Mesh Token</h1>
        {connected ? <MintSection /> : <CardanoWallet />}
      </div>
    </div>
  );
};

export default Home;

function MintSection() {
  const koiosProvider = new KoiosProvider("preprod");

  const { wallet } = useWallet();
  const [loading, setLoading] = useState < boolean > false;
  const [success, setSuccess] = useState < boolean > false;
  const [txHash, setTxHash] = (useState < string) | (undefined > undefined);

  async function startMinting() {
    setSuccess(false);
    setTxHash(undefined);
    setLoading(true);
    const recipientAddress = await wallet.getChangeAddress();
    const utxos = await wallet.getUtxos();
    console.log("starting minting", { recipientAddress, utxos });
    const { unsignedTx } = await createTransaction(recipientAddress, utxos);

    const signedTx = await wallet.signTx(unsignedTx, true);
    const txHash = await wallet.submitTx(signedTx);
    console.log({ txHash });
    setLoading(false);
    setTxHash(txHash);

    koiosProvider.onTxConfirmed(
      txHash,
      () => {
        console.log("Transaction confirmed");
        setSuccess(true);
      },
      100
    );
  }

  return (
    <>
      {txHash ? (
        <>
          <p>
            <b>Tx Hash:</b>
            <br />
            {txHash}
          </p>
          {success ? (
            <p>Transaction confirmed</p>
          ) : (
            <p>Waiting confirmation...</p>
          )}
        </>
      ) : (
        <button
          type="button"
          onClick={() => startMinting()}
          disabled={loading}
          style={{
            fontSize: "20px",
            margin: "16px",
            padding: "10px",
            backgroundColor: loading ? "orange" : "grey",
          }}
        >
          Mint Token
        </button>
      )}
    </>
  );
}

async function createTransaction(recipientAddress: string, utxos: UTxO[]) {
  const koiosProvider = new KoiosProvider("preprod");

  const appWallet = new AppWallet({
    networkId: 0,
    fetcher: koiosProvider,
    submitter: koiosProvider,
    key: {
      type: "mnemonic",
      words: [
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
        "solution",
      ],
    },
  });

  // minting script
  const appWalletAddress = appWallet.getPaymentAddress();
  const forgingScript = ForgeScript.withOneSignature(appWalletAddress);

  // define assets
  const assetName = "MeshBlueBanner";

  const assetMetadata: AssetMetadata = {
    name: "Mesh Blue Banner",
    image: "https://meshjs.dev/logo-mesh/mesh.png",
    mediaType: "image/jpg",
    description: "This NFT is minted by Mesh (https://meshjs.dev/).",
  };

  const asset: Mint = {
    assetName: assetName,
    assetQuantity: "1",
    metadata: assetMetadata,
    label: "721",
    recipient: recipientAddress,
  };

  const costLovelace = "10000000";
  const bankWalletAddress = "addr_test1qzmwuzc0qjenaljs2ytquyx8y8x02en3qxswlfcldwetaeuvldqg2n2p8y4kyjm8sqfyg0tpq9042atz0fr8c3grjmysm5e6yx";

  const selectedUtxos = largestFirst(costLovelace, utxos, true);

  // create the transaction
  const tx = new Transaction({ initiator: appWallet });
  tx.setTxInputs(selectedUtxos);
  tx.mintAsset(forgingScript, asset);
  tx.sendLovelace(bankWalletAddress, costLovelace);
  tx.setChangeAddress(recipientAddress);
  const _unsignedTx = await tx.build();
  const unsignedTx = await appWallet.signTx(_unsignedTx, true);

  return { unsignedTx: unsignedTx };
}
```
